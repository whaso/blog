---
title: python从入门到放弃
date: 2023-06-30 11:14:42
tags: python
---

# 一. 基础

- 编译型语言
  - 定义：在程序运行之前，源代码会先经过编译器将其转换为机器语言的形式，生成可执行文件。在运行时，计算机直接执行该可执行文件，无需再进行翻译或解释。C、C++ 和 Java 等语言属于编译型语言。
  - 白话定义：只有第一次执行的时候需要编译,之后如果没修改源代码就不会再编译了
  - 示例：C++、Go、Java
- 解释型语言
  - 定义：在程序运行时，源代码逐行解释并执行。解释器将源代码转换为机器语言，并逐行执行代码。解释型语言的代码无需编译，可以直接运行，但由于需要逐行解释执行，相对于编译型语言，解释型语言的执行速度通常较慢。
  - 白话定义：每次运行都会从第一行进行编译,编译一行执行一行
  - 示例：Python、JavaScript、Ruby 

## 1. 基中基

### 1.1. 关键字

| 关键字                                       | 涉及功能                         |
| -------------------------------------------- | -------------------------------- |
| True, False, None                            | 真 假 空                         |
| if, elif, else, and, not, assert, or, is, in | 逻辑判断                         |
| try, except, finally, raise                  | 异常捕获                         |
| for, while, continue, break, return          | 循环                             |
| from, import                                 | 导包                             |
| def, class, lambda                           | 定义函数、类、匿名函数           |
| async, await, yield                          | 异步                             |
| global, nonlocal                             | 变量空间                         |
| as, del, pass, with, type                    | 重命名、删除、PASS、上下文、类型 |

### 1.2. 逻辑运算符

- 与 `and`: 一假即假
- 或 `or`: 一真即真（注意短路逻辑： `1 or 1 / 0` 不会报错，程序只会走第一个1然后就会执行下一行）
- 非 `not`: 真假取反

### 1.3. 比较运算符

- `//` 取整除 9 // 4 = 2

- `%` 取余 9%4 = 1

- `^`   取异或  把数字转化为二进制取  0 1 为 1 ，1 0 为 1， 1 1 为1， 0 0 为 0

- `**`  幂

### 1.4. 比较运算符

- `> < == != >= <=`

- 返回的结果都是bool类型, True表示条件成立, False表示不成立.

### 1.5. 输入输出

- `print()` 调用底层的`sys.stdout.write`方法，前往控制台打印输出

- `input()`  无论输入什么类型的数据，都会转化为字符串

### 1.6. 循环

- 循环语句结合`else`语句使用，当循环语句执行了`break`表示非正常结束，`else`语句不会执行，否则会执行`else`语句

- 循环语句里有`break/return`时, `break/return`执行了, `else`语句就不会执行
- `break/continue` 只影响一层循环 

### 1.7. if三目运算

- `a if a > b else b` 条件成立取a，不成立取b

- if 除了判断bool类型, 还可以判断
  - 容器类型(字符串, 列表, 元组, 字典, 集合, `range()`, `bytes()`) 判断是否有数据
  - 非零即真(只要不是0, 条件都成立)
  - None 条件不成立, not none, 表示非空, 条件成立

### 1.8 注释

- 单行 `# 这是注释`
- 多行 `""" 这是多行注释 """`

## 2. 容器

### 2.1. 字符串

> **字符串用`join`比直接`+`高效原因**：在 Python 中，字符串是不可变类型，这意味着一旦我们创建了一个字符串对象，它就不能被修改或更新。因此，每次使用 `+` 操作符拼接字符串时，都会创建一个新的字符串对象，并将之前字符串对象的内容复制到新的字符串对象中，这个复制的操作会带来额外的内存分配和内存拷贝的开销，特别是在需要拼接大量的字符串时，会消耗大量的系统资源，导致程序运行缓慢。 相对地，使用 `join()` 方法的拼接字符串操作则更加高效。`join()` 方法本质上是将多个字符串通过指定的分隔符拼接在一起，而与此相关的方法包括 `split()`，`replace()` 和 `format()` 等方法，它们均采用类似的算法。在 `join()` 方法的实现中，Python 的解释器会先在内存中分配一个足够大的单个字符串缓冲区，然后扫描要拼接的字符串，将其复制到单个缓冲区中，并在不同字符串之间插入指定的分隔符。这种方法可以有效地避免频繁创建或拷贝字符串对象，从而提高拼接字符串的效率。 此外，`join()` 方法还可以接受一个可迭代对象作为参数，如列表，元组，生成器等，它们会返回一个字符串，其中可迭代对象按照指定的分隔符进行拼接。这种方式具有更高的灵活性和实用性，因为它可以用于拼接任意数量的字符串，而且可以用于迭代较大的数据集合，而不会导致系统资源消耗过多。

- 定义：用单引号、双引号、三引号均可，仅三引号可以换行
- 切片：` [开始位置:结束位置:步长] ` 左闭右开
  - `[::-1]` 字符串快速逆置

```python
my_str = "python"
isinstance(my_str, str)  # True

my_age = 18
isinstance(my_age, int)  # True

my_age = str(my_age)  # "18"
isinstance(my_age, str)  # True
```

**常用**

- `.find(要查询的字符, 查询开始索引, 查询结束索引)` 左闭右开，查空返回 -1
- `.replace(str1, str2, 替换次数)` 字符串替换，替换次数默认-1全部替换
- `.split(str1, 切片次数)` 字符串以 str1 为分隔符进行切片，切片次数默认-1全部切，返回分隔后的列表
- `.lower()` 英文转小写 `upper()`转大写

### 2.2. 列表

**定义**：`[]` 或 `list()` 

**列表推导式**： 列表中可以包含条件语句，表示筛选符合条件的元素。在这种情况下，底层逻辑还会涉及以下步骤：

1. 创建一个空列表。
2. 对于列表推导式中的每个元素表达式，按照迭代顺序依次执行以下步骤：
   1. 在当前作用域中计算元素表达式的值。
   2. 如果条件表达式的值为真，则将计算得到的值添加到列表中。
3. 返回最终生成的列表。

**增**

- `.append` 加整个对象，加字典也是整个字典
- `.extend` 打散加进去，加字典默认加字典的`key`
- `.insert(index, obj)` 在指定位置前面加, 是整个加进去的

**删**

- `del list[::]` 可以和切片一起操作根据索引删除列表元素

- `.pop()` 只能根据单独索引删除对应元素, 默认删最后一个, 会返回删除的元素

- `.remove()` 指定元素删除

**改**

`list[index] = "new"`  可以用切片同时更改多个数据,注意下面示例

```python
>>> my_list = [1, "2", 3]
>>> my_list[0] = "1"
>>> my_list
['1', '2', 3]
>>> my_list[:0] = "456"
>>> my_list
['4', '5', '6', '1', '2', 3]
>>> my_list[:2] = [1, 2]
>>> my_list
[1, 2, '6', '1', '2', 3]
```

**查**

- `in` 判断是否存在，只可判断最外层数据，内层还有容器要索引进去查
- `.index(obj, start, end)` 左闭右开，找不到报`ValueError`
- `.count(obj)`

**排序**

- `.sort(reverse=False)` 默认是从小到大, `reverse=True` 改为从大到小

- `.reverse()` 将列表逆置, 与上面的`reverse=True`不同

### 2.3. 元组

**定义**：`tuple()` 或 `(1, 2)`  如果只有一个元素, 逗号不能省略, 有序

### 2.4. 字典

**定义**

- `dict()` 或 `{"a": 1, "b": 2}`
- `zip`组合`key`和`value` 生成字典

```python
>>> keys = ["a", "b"]
>>> values = [1, 2]

>>> my_dict = dict(zip(keys, values))
>>> my_dict
{'a': 1, 'b': 2}
```

**增:**   

- `dict[key] = value`

**删:**   

- `del dict[key]`  必须要有`key`数据

- `.pop(key, default)`  必须要有`key`数据, 会返回所删项的`value`, 如果字典里没有这个`key`就会返回`default`

- `.popitem()`  takes no arguments, return the last item as a tuple()

- `.clear()` 清空

**改:**  

-  `dict[key] = value`  和增加元素相同, 所以当原本没有此`key`就变成增加元素了

**查:**   

- `dict[key]`  如果不存在会报错

- `.get(key, default)`   如果不存在则返回`default`  不写`default`找不到会返回`None` 不会报错

**合并:**  

- `dict1.update(dict2)`  把字典2的每个键值对数据合并到字典1中, 如果有重复的则更新1的内容

**遍历:** 

- `for key in dict.keys()`
- `for values in dict.values()`
- `for item in dict.items()`           **item是个tuple**
- `for key, value in dict.items()`         遍历 + 拆包

**排序：**

- `sorted(d.items(), key=lambda x : x[0/1])`

### 2.5. 集合

- 集合是一个容器类型, 可以存储多个数据, 但是多个数据不能重复
- 集合只能存储不可变类型数据, 也就是: 数字, 字符串, 元组    同字典的key
- 空集合不能使用**{}**来表示, {}是字典, 创建时用 **set()** 来创建空集合
- 遍历集合不能用通过下标, 可以用for遍历, 可迭代对象

**特点:**

1. 无序, so集合不能通过索引获取数据和通过索引修改数据
2. 数据不能重复,数据是唯一的
3. 可变类型

**操作符：**

**^**  补  {1，2} ^ {2, 3}  =>  {1, 3}

**&** 交  {1，2} & {2, 3}  =>  {2, }

**|**   并   {1，2} | {2, 3}  =>  {1, 2, 3}

**-**   差   {1，2} - {2, 3}  =>  {1, }

**增:**

.**add()** 重复的数据只保留一个

**删:**

**.remove(value)** 指定数据删除

### 2.6. 公共方法

| 运算符 | Python 表达式      | 结果                         | 描述           | 支持的数据类型           |
| ------ | ------------------ | ---------------------------- | -------------- | ------------------------ |
| +      | [1, 2] + [3, 4]    | [1, 2, 3, 4]                 | 合并           | 字符串、列表、元组       |
| *      | ['Hi!'] * 4        | ['Hi!', 'Hi!', 'Hi!', 'Hi!'] | 复制           | 字符串、列表、元组       |
| in     | 3 in (1, 2, 3)     | True                         | 元素是否存在   | 字符串、列表、元组、字典 |
| not in | 4 not in (1, 2, 3) | True                         | 元素是否不存在 | 字符串、列表、元组、字典 |

**python内置函数**

- `len()`  获取容器的元素数量

- `max()`  返回容器中元素最大值  |  类似的 `min()`  最小

- `enumerate()` 
  - 在使用for循环的时候可以遍历数据又可以遍历索引, 列表/元组/字典都可以使用
  - 当用于字典遍历所有items时返回的是一个索引数据和一个元组

### 2.7. 可变不可变类型

不可变类型

- 定义：不允许在原本内存空间基础上修改数据, 修改数据后内存地址会发生变化
- 示例：列表, 字典, 集合

可变类型

- 定义：允许在原本内存空间修改数据，修改后一是在原有内存空间基础上修改数据内存不变，二是重新赋值内存地址可能发生变化
- 示例：数字, 字符串, 元组  

## 3. 函数

> 程序中定义的变量都是保存在内存中的, 局部变量也是, 当函数执行结束后局部变量都会销毁,内存释放

### 3.1. 文档说明

```python
def show():
    """ func docs """
    # ''' others '''
    print("life is short i use python")


show()
help(show)
# life is short i use python
# Help on function show in module __main__:
# 
# show()
#     func docs
```

### 3.2. 返回值

- 函数不写`return` 取函数返回值时会取到 `None`
- 在多层循环中 `return` 可把多层全部终止，`break` 只能终止一层

### 3.3. 全局变量

- `global` 本质是表示: 要修改全局变量的内存地址, 所以只有不可变类型需要`global`

- 在函数内部使用全局变量时, 要先声明 `global` 全局变量, 如果是可变类型就不需要了

- 对于操作全局变量的数据, 如果是通过重新赋值来完成的, 那么必须加上`global`关键字

### 3.4. 函数参数

- 分类

  - 位置参数：按照位置顺序依次给函数的参数传值

  - 关键字参数：按照关键字名给函数的参数传值

  注：前面按位置, 后面按关键字, 如果前面用了关键字参数, 后面不能再使用位置参数, 只能使用关键字参数传参

- 不定长参数: 函数的参数个数不确定, 可能0个, 可能多个

  - 不定长位置参数, `*args`, 调用函数时所有位置参数都封装成元组, 赋值给`args`
  - 不定长关键字参数, `**kwargs`, 调用函数时所有关键字参数都封装成字典, 赋值给`kwargs`

  注: `*args` 和 `**kwargs` 这两个参数名可以修改, 但一般不改, 大家习惯了

```python
def show(name, *args, age=18, **kwargs):
    print("name:", name, "age:", age, "args:", args, "kwargs:", kwargs)
show("李四", 1, 2, "a", a=1, b=2, age=20)

# name: 李四 age: 20 args: (1, 2, 'a') kwargs: {'a': 1, 'b': 2}
```

- **拆包**：使用不同变量保存容器类型中的每个数据，对应的变量和数据数量要保持一致致

  -  容器类型如:字符串, 列表, 元组, 字典, range, 集合(set) 都可以利用拆包, 容器类型可以使用变量保存不同的数据

  - `*my_tuple`: 对元组/列表进行拆包, 也就是把元组/列表里每个数据按位置参数进行传参
  - `**my_dict`: 对字典进行拆包, 也就是把字典里面的每一个键值对按关键字的方式进行传参

### 3.5. 匿名函数

定义：没有名字的函数, 就是匿名函数, 匿名函数返回值不需要 `return`，用` lambda` 定义

格式:  `lambda [形参1], [形参2], ... : [单行表达式] 或 [函数调用]`

```python
>>> my_func = lambda a: print(a)
>>> my_func("hello world")
hello world
```

### 3.6. 常见函数定义

- 递归函数: 在一个函数内调用的是函数本身, 这样的函数称为递归函数
- 函数嵌套：python中, 可以在函数内部再定义一个函数, 称为函数的嵌套（例：装饰器）
- 高阶函数：函数的参数或者返回值是一个函数类型, 那么这样的函数就叫高阶函数（例：装饰器）

## 4. 文件

### 4.1. 常识

- 在windows的python解释器里面, 打开文件默认的编码格式是 `gbk` 的

- 在mac和linux的解释器里面, 打开文件默认的编码格式是 `utf-8` 的

- `utf-8` 一个汉字占用三个字节, 一个字母占1个字节

- 编码:  `.encode("utf-8")`

- 解码:  `.decode("utf-8")`

## 5. 面向对象

> 面向对象就是对面向过程的封装
>
> **面向对象的三大特性**
>
> **封装:** 把属性和方法放到类里面的操作就是封装, 封装可以控制属性和方法的访问权限
>
> **继承:** 子类可以使用父类的方法或者属性, 提高了代码的复用性, 注意点: 父类的功能满足不了子类的需要, 重写父类的方法
>
> **多态:** 
>
> - 对象调用同一个方法会出现不同的表现形式(表现结果)
> - 多态的好处, 代码的可扩展性强, 代码兼容性强, 不关系类型, 只关系对象是否具有指定功能方法

### 5.0. 类的实例化过程

1. 内存分配：Python为对象分配所需的内存空间。

2. 初始化实例：调用类的__init__方法来初始化实例。__init__方法是类中一个特殊的方法，它在实例化对象时被自动调用。

3. 创建对象引用：创建一个指向该实例的引用，允许你通过变量来访问该实例。

4. 执行__new__方法（可选）：如果定义了__new__方法，它将在__init__之前被调用。__new__方法负责创建实例。

5. 返回实例：返回一个指向新实例的引用，使你可以使用该引用来操作该实例。

总结起来，实例化一个类时，Python会为对象分配内存空间，然后调用__init__方法初始化实例，最后返回新实例的引用。这样，就可以通过该引用来操作和访问该实例的属性和方法。

### 5.1. 魔法方法

**定义**：方法名前后都有两个下划线, 这样的方法称为魔法方法, 魔法方法具有一定的特殊功能

**常见魔法方法**：

- `__new__` 分配内存的方法, 在`__init__`之前调用

- `__init__`, 在创建一个对象时默认被调用,不需要手动调用, 可以在此方法内添加对象属性

- `__del__`, 创建对象后, python解释器默认调用`__init__`方法, 当删除对象时, python解释器也会默认调用`__del__`方法

- `__str__`, 当使用`print`输出对象的时候, 默认打印对象的内存地址, 如果类定义了此方法,那么就会打印从在这个方法中`return`的数据, 此方法返回必须是字符串类型, 作为这个对象的描述信息. 

- `__slots__`方法, 限定自定义类型的的对象只能绑定某些属性, 只对当前类对象生效, 对子类并不起任何作用

- `__enter__`表示上文方法，需要返回一个操作文件对象

- `__exit__`表示下文方法，with语句执行完成会自动执行，即使出现异常也会执行该方法

**对象销毁的方式**:

- 程序运行结束, 程序中所使用对象都要在内存中销毁

- 当对象没有变量使用的时候, 该对象就会被销毁, 引用计数为0时会销毁

### 5.2. 继承

**语法**：`class 子类名(父类名):`  / `class 子类名(父类1, 父类2):`

**说明**：子类复用父类里面的属性或方法,  提高代码的复用性,  能够使用父类里面的方法或者属性, 包括`__init__`方法

**常识：**

- 父类也称为基类,  子类也称为派生类

- 单继承：子类只继承一个父类
- 多继承：子类继承多个父类, 可以使用多个父类里的方法
  - `.mro()`  方法可查看类的继承顺序
- 多层继承：只要有类继承关系, 子类对父类及所有上层父类的方法都可以使用

- 继承后方法的调用：先从本类查找, 依次往后查找, 找到就停, 如果没找到对应方法, 程序崩溃
- 重写：子类继承父类, 对父类的功能方法进行重新改造（子类方法名要和父类方法名相同）

**子类调用父类方法：**

- `self.方法()` : 当子类没有这个方法时候才可以用, 子类有相同方法时用`父类的类名.方法(self)`

- `父类的类名.方法(self)` :  类名调用对象方法, 需要自己手动传入self参数, 对象调用对象方法, 不需要传self参数

- `super().方法()` :  `super`是一个类, `super()`表示创建了一个父类对象, 通过`__init__`方法给对象添加属性 

  - 完整写法 `super(子类名称, self).父类方法()`  : 指定类名, 根据子类获取对应父类

  -  super本质: 根据指定类 在类的继承顺序**类名.mro()**中获取下一个类, 然后调用下一个类的方法, 如果是单继承, super的调用可以认为是调用的是父类的方法

### 5.3. 私有权限

1. 在属性名和方法名前加两个下划线
2. 私有属性和私有方法只能在本类中使用, 不能在类外部使用
3. 其实私有属性及方法只是对属性名和方法名进行了包装, 把名字进行了修改
4. 总结: 私有属性和方法 的包装格式: 在属性名和方法名前面加 `_本类类名__`
5. 子类无法使用父类的私有属性和私有方法, 也是把名字做了包装, 同上
6. 给对象添加私有属性只能在`__init__`方法里面完成

### 5.4. 类属性和实例属性

- **类属性**: 在类的内部init方法外部定义的属性, 类属性属于类

- - **私有类属性**: 类名前加两个下划线, 也是把名字做了包装, 实际同对象的私有

- **实例属性**: 在init方法内部定义的属性称为实例属性, 实例属性属于实例  (实例 == 对象)

- **类不能访问对象属性, 但是对象可以访问类属性(对象不能修改类属性, 只能类去修改)**
- **总结**: 对象属性的操作是由对象完成, 类属性操作由类来完成, 只不过对象可以访问类属性(也可以用 **self.__class__.类属性** 修改类属性, 用class找到类然后是类去修改类属性), 类不能访问对象属性

### 5.5. 类中方法的种类

- **实例方法**: 方法的第一个参数是self, 那么这样的方法就是对象方法, self表示当前对象, 实例方法, 类不能调用
- **类方法**(修改和获取类的私有属性时使用): 方法第一参数cls并且还需要使用`@classmethod`的关键字进行修饰, cls表示当前类, 类方法可以获取和修改类的私有属性, 类方法类和对象都可以调用

- **静态方法**: 方法里没有self和cls参数并且还需要使用`@staticmethod`的关键字进行修饰

## 6. 异常与模块

### 6.1. 异常

**异常捕获 try...except...**

- try 表示尝试执行可能出问题的代码, except 表示如果代码出现异常, 进行捕获 as e:
- 捕获异常类型的通用写法就是用Exception,  因为大多数异常类型都是最终继承Exception的
- BaseException 可以捕获任何异常

**try...except...else...finally**

- `except` 与 `else` 互斥,  `finally`不管有没有异常都执行

**异常的传递**

- 当执行代码的时候遇到错误, 首先判断当前代码块对异常进行捕获, 如果没有, 那么再把异常一层一层往外传递, 如果外界的都没对异常的捕获, 程序就会崩溃, 如果有异常捕获, 就不会崩溃了

**自定义异常**

- class定义自定义异常类, 必须继承Exception或者BaseException才可以
- 抛出自定义异常使用关键字raise
- 注意:raise只能抛出异常类的对象

### 6.2. 模块

 **通俗理解模块就是一个 .py 文件, 模块里面可以定义具体的功能代码(类, 函数, 全局变量, 匿名函数等等)**

```python
# 查看导入模块的搜索路径 
import sys 

print(sys.path)       
```

- 模块好比一个工具箱, 模块里的每一个具体代码好比一个工具
- 模块的命名规则和变量名的命名规则一样 使用下划线命名
- 模块名的组成和变量名组成一样, 字母, 数字, 下划线开头, 如果以数字开头, 这个模块就不能使用了

**导入模块的两种方式**

- import 模块名  as 别名
- from 模块名 import 功能代码(函数, 类, 全局变量)   as 别名
- from 模块名 import *  导入模块里所有功能代码 一般不这样使用

**导入模块注意点**

- 自制的模块名不要和系统的模块重名
- 使用from 模块名 import 功能, 在当前模块不要再定义导入功能的代码, 否则会覆盖之前导入功能代码

**自制模块**

- __all__ 指定导入对应的功能代码  __all__ = [类名, 类名.....]  all定义针对外界使用from 模块名 import * 导入,  只能导入all里面指定的功能代码

**主模块名字**: __main__  

**导入的模块名字**:  就是模块原本的名字

**包:** **通俗理解只要文件夹里包含一个__init__.py文件, 那么这个文件夹就是包**

- 包的作用: 包是用来管理不同模块的 
- 模块的作用: 模块是用来管理不同功能代码的
- 包名的命名规则和变量名一样, 使用下划线命名法
- 包名的组成和变量名的组成一样, 数字, 字母, 下划线 不能数字开头
- **包的特点**:

- - 包里面有一个__init__.py文件,这是包的初始化文件, 当且仅当第一次导入包的时候会执行这个文件
  - __init__.py 其实就是包的象征文件
  - __init__.py 可以控制模块的导入行为
  - __init__.py 可以定义类, 函数, 全局变量等代码

**包的导入目的使用包里面的模块**

**格式**: 

- import 包名  指定导入包, 用包调用模块, 使用模块中的功能代码 第一次导入包的时候会默认调用__init__.py  
- import 包名.模块名
- from 包名 import 模块名
- from 包名 import 模块名 as 模块别名
- from 包名 import *      默认不是导入包里所有模块, 需要在__init__.py中使用__all__去指定



# 二. 高级

## 1. 多任务



## 2. 高级语法

