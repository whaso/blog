---
title: go从入门到放弃
date: 2023-06-30 11:59:24
tags:
---

# 一. 基础

- 编译型语言
  - 定义：在程序运行之前，源代码会先经过编译器将其转换为机器语言的形式，生成可执行文件。在运行时，计算机直接执行该可执行文件，无需再进行翻译或解释。C、C++ 和 Java 等语言属于编译型语言。
  - 白话定义：只有第一次执行的时候需要编译,之后如果没修改源代码就不会再编译了
  - 示例：C++、Go、Java
- 解释型语言
  - 定义：在程序运行时，源代码逐行解释并执行。解释器将源代码转换为机器语言，并逐行执行代码。解释型语言的代码无需编译，可以直接运行，但由于需要逐行解释执行，相对于编译型语言，解释型语言的执行速度通常较慢。
  - 白话定义：每次运行都会从第一行进行编译,编译一行执行一行
  - 示例：Python、JavaScript、Ruby 
- 静态语言
  - 如果在编译时知道变量的类型, 则为静态类型语言. 优点是编译器可以执行各种检查, 程序没跑起来就能找到一些小错误
  - 示例：C++、Go、Java 
- 动态语言
  - 定义：在运行期间过才去做数据类型检查的语言, 在用动态语言编程时, 不用给变量指定数据类型, 该语言会丰第一次赋值给变量时, 在内部将数据类型记录下来, 不必每次都指定类型
  - 示例：Python, PHP,  JavaScript
- 强类型
  - 定义：为所有变量指定数据类型称之为"强类型", 不允许两种不同类型的变量相互操作
  - 示例：Python, Go, Java, C#
- 弱类型
  - 定义：也称为弱类型定义语言, 一个变量可以赋不同数据类型的值, 允许将一块内存看做多种类型, 比如直接将整型变量与字符变量相加
  - 示例：C, C++, JavaScript, PHP

## 1. 基中基

> 在 Python 中，要实现并发编程，通常需要使用特定的库或框架，如 threading、multiprocessing、asyncio 等。这些库提供了线程、进程、协程等抽象，用于实现并发任务的调度和执行。Python 的标准库提供了一些基本的并发工具，但在处理大规模并发时可能需要使用更高级的第三方库。
>
> 而在 Go 中，原生的 Goroutine 和调度器提供了并发编程的内置支持，不需要依赖额外的框架或库。Goroutine 是 Go 语言提供的一种轻量级的并发执行单元，通过使用关键字 `go` 来启动 Goroutine，无需额外的线程或进程管理。调度器会自动将 Goroutines 调度到可用的系统线程上执行，并进行高效的并发调度。
>
> 由于 Goroutines 是 Go 语言内部的机制，Go 运行时系统负责管理 Goroutines 的创建、调度和销毁，使得并发编程在 Go 中变得非常简单和高效。此外，Go 还提供了通道（Channel）作为 Goroutines 之间进行通信和同步的机制，进一步简化了并发编程的复杂性。
>
> 总结:  Go 在语言本身就提供了原生的并发支持，使用 Goroutine 和调度器实现轻量级的并发编程。相比之下，Python 需要借助额外的库或框架来处理并发任务，并且在处理大规模并发时可能需要使用更高级的工具。
>
> Goroutine 是 Go 语言中并发编程的核心概念之一，它是一种轻量级的执行单元。每个 Goroutine 都是一个独立的执行线程，可以与其他 Goroutines 并发地执行。
>
> Goroutine 可以看作是一种比传统线程更轻量级、更高效的并发编程抽象。与传统的线程相比，Goroutine 的创建和销毁开销很小，可以高效地创建大量的 Goroutines。这使得在 Go 语言中可以方便地使用大量的 Goroutines 来实现并发任务，而不会消耗过多的系统资源。
>
> 使用 Goroutines 的一个重要特点是它们之间的切换开销非常低。由于 Goroutines 是由 Go 调度器（Scheduler）管理的，调度器可以在 Goroutines 之间非常高效地进行切换，以实现并发执行。当一个 Goroutine 遇到阻塞操作（例如等待 I/O 完成或休眠）时，调度器会自动切换到其他可执行的 Goroutine，以充分利用系统资源。
>
> 另一个重要特点是 Goroutines 之间可以通过通道（Channel）进行通信和同步。通道是 Goroutines 之间安全地传递数据的机制，可以用于在不同的 Goroutines 之间进行数据交换和共享。
>
> 通过使用 Goroutines，开发者可以将任务并发地划分为多个独立的执行单元，每个执行单元由一个 Goroutine 来处理。这样可以简化并发编程的复杂性，并充分发挥多核处理器的性能优势。
>
> 总结: Goroutine 是 Go 语言中的一种轻量级并发执行单元，它提供了高效的并发编程抽象。通过使用 Goroutines，开发者可以方便地实现并发任务，并充分利用多核处理器的性能。同时，通过通道的机制，Goroutines 可以安全地进行通信和同步，实现高效的并发编程。



### 1.1. 编译器下载安装

> 官网：https://golang.org/dl/

- mac
  - 下载*.pkg直接安装 默认安装目录 `/usr/local/go`
  - 添加**/usr/local/go/bin**目录到环境变量 `export PATH=$PATH:/usr/local/go/bin`

### 1.2. Hello World

```go
package main import "fmt" func main() {   
  fmt.Printf("Hello, Go\n") 
} /* main 是入口, 名固定不能改 */

$ go build hello.go 
$./hello 

>> Hello, Go
```

- package main 包声名, 必须在源文件非注释第一行声名这个文件属于哪个包, 每个Go程序都必须有一个名为 main 的包
- import "fmt" 导入包, 表示这个程序需要"fmt"包, 注: "fmt" go的格式化输入输出包
- func main() {} go的第一个程序都必须有一个main函数, 这是程序入口, go程序执行顺序: init -> main -> 其他, 没有init就main最先执行

**注: 当标识符以大写字母开头****（包括常量、变量、类型、函数名、结构字段等等）表示可被外部包使用, 以小写字母开头表示不可被外部包使用(但对包内部是可用的)

### 1.3. 基础

- 注释
  - `//` 单行注释
  - ` /*` 多行注释 `*/`

- 标识符: 由字母, 数字, 下划线构成, 不能数字开头, 不能是go的关键字
- 关键字:

> 官方文档：https://go.dev/ref/spec#Keywords

| 关键字                                                       | 涉及功能 |
| ------------------------------------------------------------ | -------- |
| select, case, if, else, switch, default                      | 逻辑判断 |
|                                                              | 异常捕获 |
| for, continue, break, return                                 | 循环     |
| import, package,                                             | 导包     |
| func, interface                                              | 定义     |
|                                                              | 异步     |
|                                                              | 变量空间 |
| , select, defer, go, map, struct, chan, goto, range, type, const, fallthrough, var | 其他     |

- 预定义标识符:

| 标识符                              | 含义                                                   |
| ----------------------------------- | ------------------------------------------------------ |
| bool, true, false                   | 布尔类型， 真，假                                      |
| byte                                | alias for uint8                                        |
| rune                                | alias for int32                                        |
| int, int8, int16, int32, int64      | 整数类型关键字, 有符号整数类型的不同位数               |
| uint, uint8, uint16, uint32, uint64 | 无符号整数类型的关键字, 无符号整数类型的不同位数       |
| uintptr                             | 用于存储指针值的整数类型                               |
| float32, float64                    | 浮点数类型的不同精度                                   |
| complex32, complex64                | 复数类型的不同精度                                     |
| string                              | 字符串类型的关键字                                     |
| error                               | 表示错误类型的接口                                     |
| make                                | 用于创建切片、映射和通道的内建函数                     |
| new                                 | 用于分配内存的内建函数                                 |
| append                              | 用于向切片追加元素的内建函数                           |
| len                                 | 用于返回切片、数组、字典、字符串或通道的长度的内建函数 |
| cap                                 | 对于切片或容量为数组、切片或通道的内建函数，返回其容量 |

### 1.4. 数据类型

- 布尔: true / false
- 数字: uint8 / uint16 / uint32 / uint64 (无符号 0-255-65535-...) / int8 / int16 / float32 / float64 ( -128-127 -32768 - 32768 .. ..)
- 字符串: utf-8
- 派生类型: 
