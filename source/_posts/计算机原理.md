---
title: 计算机原理
date: 2022-02-20 14:59:37
tags: Basic
categories: 计算机原理
---

# 计算机组成原理

## 1. Basic

### 1.1. 基本组成

**五大部分**

- **运算器**  (CPU) (主机): 算术运算、逻辑运算
- **控制器**  (CPU) (主机): 指挥各部件, 使程序运行
- 存储器 : 存放数据和程序
  - **主存**  (主机)
  - 辅存  (I/O设备)
- **输入设备**  (I/O设备)
- **输出设备**  (I/O设备)

### 1.2. 各硬件部分

> 寄存, 就是暂存数据的意思, 类似快递点

**主存储器**

> 存储体存数据, MAR对应数据位置(主存地址), MDR暂存对应的实际数据
>
> 类似快递点: 存储体=> 货架,  MAR => 店员,  MDR => 取货/放货 的柜台
>
> 取数据过程: CPU把地址给到MAR, 把读指令给到主存储器, 主存储器把存储体MAR地址的数据放到MDR等待使用
>
> 存数据过程: CPU把地址给到MAR, 把数据放到MDR, 把写指令给到主存储器, 主存储器根据指令把MDR中数据存储到存储体的MAR地址

- 存储体: 数据在存储体中按地址存储, 每个地址对应一个存储单元
  - 存储单元: 每个存储单元存放一串二进制代码
    - 存储元: 即存储二进制的电子元件, 每个存储元可存1bit
  - 存储字: 存储单元中二进制的组合
  - 存储字长: 存储单元中二进制代码的位数
- MAR: 存储地址寄存器, 用于指明要读/写哪个存储单元, 其位数反映存储单元数量 Memory Address Register 
- MDR: 存储数据寄存器, 用于暂存要读/写的数据, 其位数=存储字长 Memory Data Register 

**运算器**: 用于实现算术运算(+ - * /)、逻辑运算(与/非)

> 前三个存数据, ALU执行(运算)

- ACC: 累加计数器, 存放操作数、运算的结果 Accumulator
- MQ: 乘商寄存器, 进行乘、除法时用  Multiple-Quotient Register
- X: 通用寄存器, 存放操作数
- ALU: 算数逻辑单元, 用电路实现各种算数运算、逻辑运算  Arthmetic and Logic Unit

**控制器**

> PC + IR 取指令, CU执行

- PC: 程序计数器, 存放下一条指令的地址  Program Counter
- IR: 指令寄存器, 存放当前执行的指令    Instruction Register
- CU: 控制单元, 分析指令, 给出控制信息 Control Unit

**工作过程**

- 初始: 指令、数据存入主存, PC指向第一条指令
- 从主存中取指令放入IR、PC自动加1, CU分析指令, CU指挥其他部件执行指令

### 1.3. 计算机系统层次结构

| 微程序机器M0         | 传统机器M1         | 虚拟机器M2                   | 虚拟机器M3                   | 虚拟机器M4                   |
| -------------------- | ------------------ | ---------------------------- | ---------------------------- | ---------------------------- |
| 微指令系统           | 用机器语言的机器   | 操作系统机器                 | 汇编语言机器                 | 高级语言机器                 |
| 硬件                 | 硬件               | 软件                         | 软件                         | 软件                         |
| 由硬件直接执行微指令 | 执行二进制机器指令 | 向上提供"广义指令"(系统调用) | 用汇编程序翻译成机器语言程序 | 用编译程序翻译成汇编语言程序 |
| 微指令1 / 2 / 3      | 000010000000101    |                              | LOAD 5                       | y=a*b + c                    |

**三种级别的语言**

- 机器语言: 二进制代码
- 汇编语言: 助记符
  - 将汇编语言翻译成机器语言
- 高级语言: C, Python
  - 编译程序(编译器): 将高级语言一次全部翻译为汇编语言, 或直接翻译为机器语言
  - 解释程序(解释器): 将高级语言翻译为机器语言, 翻译一句执行一句

### 1.4. 存储器的性能指标

- CPU主频: CPU内数字脉冲信号振荡的频率 (Hz)
- CPU时钟周期 = 1 / CPU主频  (秒)
- CPI(Clock cycle Per Instruction): 执行一条指令所需的时钟周期数

> 不同的指令, CPI不同, 甚至相同的指令, CPI也可能变化

- 执行一条指令的耗时 = CPI * CPU时钟周期
- IPS(Instructions Per Second): 每秒执行多少条指令  = 主频 / 平均CPI   (KMGT  Kilo=10 ** 3  Million=10 ** 6)
- FLOPS(Floating-point Operations Per Second): 每秒执行多少次浮点运算  (KMGT  Giga=10 ** 9  Tera=10 ** 12)

### 1.5. 系统整体的性能指标

> 描述存储容量, 文件大小时: K = 2^10, M=2^20, G=2^30, T=2^40
>
> 描述频率, 速率时: K=10^3, M=10^6, G=10^9, T=10^12

- 数据通路带宽: 数据总线一次所能并行传送信息的位数(各硬件部件通过数据总线传输数据)
- 吞吐量: 指系统在单位时间内处理请求的数量
- 响应时间: 指从用户向计算机发送一个请求, 到系统对该请求做出响应并获得它所需要的结果的时间
- 基准程序: 用来测量计算机的一种实用程序(跑分软件)

## 2. 数据的表示和运算

### 2.1. 进位计数制

- 位权: 由符号的位置反映权重
- 基数: 每个数码位所用到的不同符号的个数, r进制的基数为r

- 计算机使用二进制
  - 可使用两个稳定状态的物理器件表示
  - 0，1正好对应逻辑值 真、假。方便实现逻辑运算
  - 可很方便地使用逻辑门电路实现算术运算
- 二进制 >> 八进制： 3位一组，每组转换成对应的八进制符号
- 二进制 >> 十六进制： 3位一组
- 十进制 >> r进制
  - 整数部分：除基取余法，先取得的“余”是整数的低位
  - 小数部分：乘基取整法，先取得的“整”是小数的高位

| 2^12^ | 2^11^ | 2^10^ | 2^9^ | 2^8^ | 2^7^ | 2^6^ | 2^5^ | 2^4^ | 2^3^ | 2^2^ | 2^1^ | 2^0^ | 2^-1^ | 2^-2^ | 2^-3^ |
| ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ----- | ----- |
| 4096  | 2048  | 1024  | 512  | 256  | 128  | 64   | 32   | 16   | 8    | 4    | 2    | 1    | 0.5   | 0.25  | 0.125 |

> 参考上图可知有部分小数是无法用二进制精确表示的

- 真值： 实际的带正负号的数值（人类习惯的样子）
- 机器数：把正负号数字化的数（存到机器里的样子）

### 2.2. BCD码

> 二进制转十进制时按乘转换麻烦, 所以用BCD转换
>
> BCD: Binary-Coded Decimal, 用二进制编码的十进制

- **8421码**

映射关系:

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |

例:

十进制:   5  +  8                     13

十进制: 0101  +  1000         1101 

 8421码中 1010 ~ 1111 没有定义 需要 + 0110 做数据修正(强制向高位进1) 上例得  0001 0011 即 13

4个十进制位 -->> 16种不同的状态

BCD码只使用其中的10种  -->> 不同的映射方案

- **余3码:**  8421码  +  (0011)~2~

映射关系:

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |

- **2421码:**  改变权值的定义

XXXX -> 2421  并规定 0~4 开头是0  5~? 开头是1

映射关系:

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 1011 | 1100 | 1101 | 1110 | 1111 |

### 2.3. 字符与字符串

#### 2.3.1. ASCII码

> 常用的数字、字母、符号(英文)共128个字符 --> 7个二进制编码  --> ASCII码 
>
> 存入计算机通常在高位补个0, 凑足1B(字节)  即 8bit
>
> 可印刷字符: 32~126, 其余为控制、通信字符
>
> 规律:
>
> ​	数字: 48(0011 0000) ~ 57(0011 1001) 后面一个比特位刚好是数字对应的8421码
>
> ​	大写字母: 65(0100 0001) ~ 90(0101 1010) 前三个010 后面为1~26
>
> ​	小写字母: 97(0110 0001) ~ 122(0111 1010) 前三个011 后面为1~26
>
> ```python
> ord('a') - ord('A') == 32
> >> True
> ```

![image-20220724170433901](..\images\image-20220724170433901.png)

#### 2.3.2. 汉字的表示和编码

1980年 GB 2312-80: 汉字+各种符号共7445个

区位码: 94个区,  每区94个位置(即94行, 94列)

国标码: 为防止信息交换时与"控制/通信字符"冲突,  在区位码基础上加32(16进制: 20H)

> 国标码已可保证数据传输, 但无法和ASCII做区分

汉字内码: 保证高位为1, 与ASCII码做区分, 在国标码基础上加128 (1000, 0000) (16进制: 80H)

> 汉字内码可以保证数据在计算机内部的处理, 计算机发现高位为1时可判断出是汉字

例: 

| 汉字(十进制) | 区位码(十六进制) | 国标码(十六进制) | 汉字内码(十六进制) |
| ------------ | ---------------- | ---------------- | ------------------ |
| 啊(16 01)    | 10H 01H          | 30H 21H          | B0H A1H            |

输入：输入编码

> 拼音  a1 => 国标码 => 汉字内码

输出：汉字字形码

> 就是对应到一个字块的像素

#### 2.3.3. 字符串

- 从低地址到高地址逐个字符存储, 很多语言中,  '\0'作为字符串结尾标识
- 对于多字节的数据(如汉字),  可采取大/小端存储模式
- 大/小端模式: 将数据的最高有效字节存放在低/高地址单元中

### 2.4. 奇偶校验

#### 2.4.1. 原理

- 码字: 由若干位代码组成的一个字

- 将两个码字逐位进行对比,  具有不同的位的个数称为两个码字间的距离
- 码距(d): 一种编码方案可能有若干个合法码字,  各合法码字间的最小距离我称为码距

- 当d = 1时, 无检错能力
- 当d = 2时, 有检错能力
- 当d = 3 时, 可能有检错、纠错能力

奇校验码: 整个校验码(有效信息位和校验位) 中的 1 个个数为奇数

| 奇/偶 校验位 | 信息位 |
| ------------ | ------ |
| 1/0          | n      |

偶校验硬件实现: 

- 计算校验位的值:  各信息进行异或运算, 得到的结果即为偶校验位

- 校验:  对所有位进行异或, 结果为1说明出错

#### 2.4.2. 海明码

> 由于奇偶校验的策略仅加了一个比特位,  只能携带2种状态, 能发现数位错误,  但无法确定是哪一位出错
>
> 海明码是在原数据中的一些固定位置，插入一个0（或1），以进行奇（或偶）校验位，虽然使原数据变长，但可使其拥有纠错能力。
> 能侦测并更正一个比特的错误；若有两个比特出错，则只能侦测，不能更正；若有三个或更多的比特出错，则不能侦测，更不能更正。

海明码设计思路:  将信息位分组进行偶校验 => 多个校验位 => 多个校验位标注出错位置

n个信息位  k个校验位  共 n+k 位  2^k种状态

公式:  2^k^  >= n + k + 1

| n    | 1    | 2-4  | 5-11 | 12-26 | 27-57 | 58-120 |
| ---- | ---- | ---- | ---- | ----- | ----- | ------ |
| k    | 2    | 3    | 4    | 5     | 6     | 7      |

**求解步骤**

信息位： 1010

1. 确定海明码的位数：2^k^ >= n + k + 1

n = 4  一> k = 3

设信息位D~4~D~3~D~2~D~1~(1010)，共4位，校验位P~1~P~2~P~3~,  共3位， 对应海明码为H~7~H~6~H~5~H~4~H~3~H~2~H~1~.

2. 确定校验位的分布

> 校验位P~i~ 放在海明码位号为2^i-1^的位置上，其余信息位顺序放

| H~7~ | H~6~ | H~5~ | H~4~ | H~3~ | H~2~ | H~1~ |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| D~4~ | D~3~ | D~2~ | P~3~ | D~1~ | P~2~ | P~1~ |
| 1    | 0    | 1    | 0    | 0    | 1    | 0    |

3. 求校验位的值

H~3~  :  3  转二进制  0   1   1

H~5~  :  5     --->>>    1   0   1

H~6~  :  6     --->>>    1   1   0

H~7~   : 7      ---->>>   1   1  1

> 根据P下标对应二进制位的权重进行分组

​		P1 对应二进制权重1的位置为1的信息位 H3 H5 H7 再根据对应信息位的值求异或得 0

​		P2 对应二进制权重2的位置为1的信息位 H3 H6 H7 再根据对应信息位的值求异或得 1

​		P3 对应二进制权重4的位置为1的信息位 H5 H6 H7  再根据对应信息位的值求异或得 0

4. 纠错

> 校验方程：校验位及其对应分组值求异或  为0即无错误

接收到：1010010 无错误

接收到：1010000  H2位错误

​		S1 => P1 H3 H5 H7  => H1 H3 H5 H7  => 0011 => 0

​		S2 => P2 H3 H6 H7  => H2 H3 H6 H7  => 0001 => 1

​		S3 => P3 H3 H5 H7  => H4 H3 H5 H7  => 0011 => 0

错误位即： 010 => H2











